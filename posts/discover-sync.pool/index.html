<!DOCTYPE html>
<html lang='en'><head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='其实很久之前就用到了这个东西，起因是collecter程序占用太多内存了，然后就用sync.Pool复用额外消耗的一次性内存，避免GC周期太长使内存来不及释放而导致的OOM。
https://golang.org/pkg/sync/#Pool
简单的说，就是在一个池子里放了一些“东西”，这些东西是某种特殊的类型，用的时候需要指定。
池子会随着你的取用而扩张，比如说，池子里面放了扳手（扳手池），现在有10个工人依次取用，当第一个人取的时候，“扳手池”发现没有扳手，ok，new一个出来; 当第一个工人用完了的时候，把扳手放回扳手池，然后第二个人取的时候，扳手池就直接返回那个扳手就可以了。嗯……如果第一个工人没有归还呢，那么扳手池就要重新new一个扳手了，也就是这种情况：10个工人同时取用扳手，那么扳手池就得new10个新的出来了。
一个测试：
https://gist.github.com/wrfly/7de7f1e0c87860aa2f92dc6ed64cb75b
Makefile：
.PHONY: build run test NAME := $(shell basename `pwd`) build: go build run: ./$(NAME) test: build run go tool pprof -lines $(NAME) mem.porf  上面那个gist中，有几个测试，在这种情况下：
wg.Add(alloc) for i := 0; i &lt; alloc; i&#43;&#43; { go func(num int) { // justMake() 	// bufPoolGet() 	bufPoolGetAndPut(num) // bufPoolSleepAndGetAndPut(num) 	wg.Done() }(i) } 也就是拿了接着放回去的时候，结果如下：
➜ syncPool_mem_usage_test make run go build ./syncPool_mem_usage_test newmake: 4 reused: 9996 reused slice(maybe equal to newmake) len: 0 ➜ syncPool_mem_usage_test  也就是说，新分配了4个1e6长度的[]byte，其余的都是复用的。'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='Discover-sync.Pool • wrfly&#39;s blog'>
<meta property='og:description' content='其实很久之前就用到了这个东西，起因是collecter程序占用太多内存了，然后就用sync.Pool复用额外消耗的一次性内存，避免GC周期太长使内存来不及释放而导致的OOM。
https://golang.org/pkg/sync/#Pool
简单的说，就是在一个池子里放了一些“东西”，这些东西是某种特殊的类型，用的时候需要指定。
池子会随着你的取用而扩张，比如说，池子里面放了扳手（扳手池），现在有10个工人依次取用，当第一个人取的时候，“扳手池”发现没有扳手，ok，new一个出来; 当第一个工人用完了的时候，把扳手放回扳手池，然后第二个人取的时候，扳手池就直接返回那个扳手就可以了。嗯……如果第一个工人没有归还呢，那么扳手池就要重新new一个扳手了，也就是这种情况：10个工人同时取用扳手，那么扳手池就得new10个新的出来了。
一个测试：
https://gist.github.com/wrfly/7de7f1e0c87860aa2f92dc6ed64cb75b
Makefile：
.PHONY: build run test NAME := $(shell basename `pwd`) build: go build run: ./$(NAME) test: build run go tool pprof -lines $(NAME) mem.porf  上面那个gist中，有几个测试，在这种情况下：
wg.Add(alloc) for i := 0; i &lt; alloc; i&#43;&#43; { go func(num int) { // justMake() 	// bufPoolGet() 	bufPoolGetAndPut(num) // bufPoolSleepAndGetAndPut(num) 	wg.Done() }(i) } 也就是拿了接着放回去的时候，结果如下：
➜ syncPool_mem_usage_test make run go build ./syncPool_mem_usage_test newmake: 4 reused: 9996 reused slice(maybe equal to newmake) len: 0 ➜ syncPool_mem_usage_test  也就是说，新分配了4个1e6长度的[]byte，其余的都是复用的。'>
<meta property='og:url' content='https://wrfly.kfd.me/posts/discover-sync.pool/'>
<meta property='og:site_name' content='wrfly&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='posts'><meta property='article:tag' content='go'><meta property='article:tag' content='share'><meta property='article:published_time' content='2018-02-20T20:05:06&#43;08:00'/><meta property='article:modified_time' content='2018-02-20T20:05:06&#43;08:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.55.6" />

  <title>Discover-sync.Pool • wrfly&#39;s blog</title>
  <link rel='canonical' href='https://wrfly.kfd.me/posts/discover-sync.pool/'>
  
  
  <link rel='icon' href='/favicon.svg'>
<link rel='stylesheet' href='/assets/css/main.6a060eb7.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-62244864-7', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head>
<body class='page type-posts'>

  <div class='site'><a class='screen-reader-text' href='#content'>Skip to Content</a><div class='main'><nav id='main-menu' class='menu main-menu' aria-label='Main Menu'>
  <div class='container'>
    
    <ul><li class='item'>
        <a href='/'>Home</a>
      </li><li class='item'>
        <a href='/tags/'>tags</a>
      </li><li class='item'>
        <a href='/posts/'>posts</a>
      </li><li class='item'>
        <a href='/links/'>links</a>
      </li><li class='item'>
        <a href='/about/'>About</a>
      </li><li class='item'>
        <a href='/repos/'>Repos</a>
      </li></ul>
  </div>
</nav><div class='header-widgets'>
        <div class='container'></div>
      </div>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>wrfly&#39;s blog</p><p class='desc site-desc'>使生如夏花之绚烂，死如秋叶之静美</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Discover-sync.Pool</h1>
      

    </div>
    <div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Posted on </span>
  <time class='entry-date' datetime='2018-02-20T20:05:06&#43;08:00'>2018, Feb 20</time>
</span>

  
  

</div>


  </div>
</header>

  
  

  <div class='container entry-content'>
  

<p>其实很久之前就用到了这个东西，起因是collecter程序占用太多内存了，然后就用<code>sync.Pool</code>复用额外消耗的一次性内存，避免GC周期太长使内存来不及释放而导致的OOM。</p>

<p><a href="https://golang.org/pkg/sync/#Pool" target="_blank">https://golang.org/pkg/sync/#Pool</a></p>

<p>简单的说，就是在一个池子里放了一些“东西”，这些东西是某种特殊的类型，用的时候需要指定。</p>

<p>池子会随着你的取用而扩张，比如说，池子里面放了扳手（扳手池），现在有10个工人依次取用，当第一个人取的时候，“扳手池”发现没有扳手，ok，new一个出来; 当第一个工人用完了的时候，把扳手放回扳手池，然后第二个人取的时候，扳手池就直接返回那个扳手就可以了。嗯……如果第一个工人没有归还呢，那么扳手池就要重新new一个扳手了，也就是这种情况：10个工人<strong>同时</strong>取用扳手，那么扳手池就得new10个新的出来了。</p>

<p>一个测试：</p>

<p><a href="https://gist.github.com/wrfly/7de7f1e0c87860aa2f92dc6ed64cb75b" target="_blank">https://gist.github.com/wrfly/7de7f1e0c87860aa2f92dc6ed64cb75b</a></p>

<p>Makefile：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-makefile" data-lang="makefile"><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> build run test
NAME <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>shell basename <span style="color:#e6db74">`</span>pwd<span style="color:#e6db74">`</span><span style="color:#66d9ef">)</span>

<span style="color:#a6e22e">build</span><span style="color:#f92672">:</span>
	go build

<span style="color:#a6e22e">run</span><span style="color:#f92672">:</span>
	./<span style="color:#66d9ef">$(</span>NAME<span style="color:#66d9ef">)</span>

<span style="color:#a6e22e">test</span><span style="color:#f92672">:</span> build run
	go tool pprof -lines <span style="color:#66d9ef">$(</span>NAME<span style="color:#66d9ef">)</span> mem.porf
</code></pre></div>
<p>上面那个gist中，有几个测试，在这种情况下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">alloc</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">alloc</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">num</span> <span style="color:#66d9ef">int</span>) {
			<span style="color:#75715e">// justMake()
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// bufPoolGet()
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">bufPoolGetAndPut</span>(<span style="color:#a6e22e">num</span>)
			<span style="color:#75715e">// bufPoolSleepAndGetAndPut(num)
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}(<span style="color:#a6e22e">i</span>)
	}</code></pre></div>
<p>也就是拿了接着放回去的时候，结果如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">➜  syncPool_mem_usage_test make run
go build
./syncPool_mem_usage_test
newmake: <span style="color:#ae81ff">4</span>
reused: <span style="color:#ae81ff">9996</span>
reused slice<span style="color:#f92672">(</span>maybe equal to newmake<span style="color:#f92672">)</span> len: <span style="color:#ae81ff">0</span>
➜  syncPool_mem_usage_test </code></pre></div>
<p>也就是说，新分配了4个1e6长度的<code>[]byte</code>，其余的都是复用的。</p>

<p>但是这里有要注意的是，如果将 buf 中的内容打印出来（上面的num），reuse的效率就会下降几个数量级了，我还试过用append的方式将复用的内容追加到某个地方，复用的buf也会减少很多很多，分析原因，认为不论是print还是append都会占用时间，影响了Put的效率，从而Get的时候就Get慢了，就new了新的出来。</p>

<p>嗯，其实上面是为了测试Pool里面到底存了多少东西，是把所有put进去的都存了，还是只存了最后put进去的。</p>

<p>该程序最后加了这么一段：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">alloc</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufPool</span>.<span style="color:#a6e22e">Get</span>()
		<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.([]<span style="color:#66d9ef">byte</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">buf</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;reuse %s&#34;</span>, <span style="color:#a6e22e">buf</span>)
		}
	}</code></pre></div>
<p>发现结果跟理论有很大出入，按理说应该打印make的那几个，但有时候回打印，有时候就没有。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">➜  syncPool_mem_usage_test make run
go build
./syncPool_mem_usage_test
reuse <span style="color:#f92672">[</span><span style="color:#ae81ff">2</span><span style="color:#f92672">]</span>
reuse <span style="color:#f92672">[</span><span style="color:#ae81ff">175</span><span style="color:#f92672">]</span>
reuse <span style="color:#f92672">[</span><span style="color:#ae81ff">174</span><span style="color:#f92672">]</span>
reuse <span style="color:#f92672">[</span><span style="color:#ae81ff">210</span><span style="color:#f92672">]</span>
newmake: <span style="color:#ae81ff">13</span>
reused: <span style="color:#ae81ff">9987</span>
reused slice<span style="color:#f92672">(</span>maybe equal to newmake<span style="color:#f92672">)</span> len: <span style="color:#ae81ff">4</span>
➜  syncPool_mem_usage_test </code></pre></div>
<p>应该是被整没了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">// Any item stored in the Pool may be removed automatically at any time without
// notification. If the Pool holds the only reference when this happens, the
// item might be deallocated.
//</pre></div>
<p>所以放里面的东西并不保险，内存是会省的，但东西会丢。</p>

<p>所以说，池子里面的东西，会丢，比如new了10个扳手，再用的时候里面也许就只有8个了，有两个被销毁了（be removed automatically at any time without notification）（也是够狠的），然后就找不到他们了，想再用的话，就只能new新的。</p>

<p>gist中还有不同的测试，最主要的是对内存消耗的测试。其实不用测也知道，GetAndPut是最省内存的，上面只是验证理论，毕竟不能别人说啥就是啥，是吧。</p>

<p>感兴趣的同学可以把代码和Makefile都跑一跑，在我这里：</p>

<ul>
<li><code>justMake</code>用了<code>148.59MB</code></li>
<li><code>bufPoolGet</code>用了<code>27.02MB</code></li>
<li><code>bufPoolGetAndPut</code>用了<code>1.13MB</code></li>
<li><code>bufPoolSleepAndGetAndPut</code>用了<code>332.07MB|282.54MB|16137.43kB|56.28MB</code> 总之结果差异很大…… 可能是时间的原因，没验证（但这个结果的确很蹊跷，值得深究）</li>
</ul>

<p>消耗不了多少内存。</p>

<h4 id="结论">结论</h4>

<p>在高并发的情况下，使用<code>sync.Pool</code>能够节省内存.</p>

</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'><div class='categories'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>
<span class='screen-reader-text'>Categories: </span><a class='category' href='/categories/dev/'>dev</a>, <a class='category' href='/categories/share/'>share</a>, <a class='category' href='/categories/go/'>go</a></div>
<div class='tags'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
<span class='screen-reader-text'>Tags: </span><a class='tag' href='/tags/go/'>go</a>, <a class='tag' href='/tags/share/'>share</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='/posts/rwmutex-and-sync.map/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader-text'>Previous post: </span>RWMutex-and-sync.Map</a>
    </div><div class='next-entry sep-before'>
      <a href='/posts/go-scheduler/'>
        <span class='screen-reader-text'>Next post: </span>Go-Scheduler<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p> &copy; 2014-2019 wrfly </p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__assets_js_src="/assets/js/"</script>

<script src='/assets/js/main.67d669ac.js'></script>

</body>

</html>

