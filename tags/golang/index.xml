<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on wrfly&#39;s blog</title>
    <link>https://wrfly.kfd.me/tags/golang/</link>
    <description>Recent content in Golang on wrfly&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 16 Apr 2019 22:13:25 +0800</lastBuildDate>
    
	<atom:link href="https://wrfly.kfd.me/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang-Open-File</title>
      <link>https://wrfly.kfd.me/posts/golang-open-file/</link>
      <pubDate>Tue, 16 Apr 2019 22:13:25 +0800</pubDate>
      
      <guid>https://wrfly.kfd.me/posts/golang-open-file/</guid>
      <description>很久之前遇到的问题了，清任务的时候这个write排第一，就写一下。
起因 要做一个临时的告警系统，又不想引入DB，也不想用bolt，不想引入额外的包，所以就傻了吧唧的自己用文件实现一个简单的DB。
（现在回想起来真的很没必要，老老实实用boltdb多好，简单快速搞得定）
每一条告警都有自己的hash，如果在文件中没有发现这条hash，则发送告警并将hash写入文件，如果发现了则跳过，目的是防止重复告警。
很简单的逻辑，但bug是，还是会发送重复的告警，也就是说，如果这条告警半小时之前发过了，那么半小时之后还会再发。（程序是用cron job跑的，每半小时跑一次，查询各个状态，如果指标低于阈值则告警）
经过 程序的某个部分是这样写的：
fileName := &amp;#34;/tmp/alert-history.txt&amp;#34; f, err := os.OpenFile(fileName, os.O_RDWR, 0644) if err != os.ErrNotExist { panic(fmt.Sprintf(&amp;#34;open file %s error: %s&amp;#34;, fileName, err)) } else { f, err = os.Create(fileName) if err != nil { panic(fmt.Sprintf(&amp;#34;create file %s error: %s&amp;#34;, fileName, err)) } } defer f.Close() // detect alarm 	// ...  // if alarm not in file 	// then send alarm and 	// write its hash to the file 	// .</description>
    </item>
    
    <item>
      <title>Golang-For-Loop</title>
      <link>https://wrfly.kfd.me/posts/golang-for-loop/</link>
      <pubDate>Sun, 25 Nov 2018 14:34:14 +0800</pubDate>
      
      <guid>https://wrfly.kfd.me/posts/golang-for-loop/</guid>
      <description>😀
Recently my colleague meets a problem with golang for loop. He ranged an array of User, wanted to filter some user and append them (use pointer to get their address) to another user array, but finally got an array contains the same user.
Some thing like this:
newUsers := []*User{} for _, u := range UserArray{ if checkFailed(u){ continue } newUsers = append(newUsers, &amp;amp;u) } The newUsers got the same user with different indexes.</description>
    </item>
    
    <item>
      <title>Gracefully-Shutdown</title>
      <link>https://wrfly.kfd.me/posts/gracefully-shutdown/</link>
      <pubDate>Wed, 03 Jan 2018 23:03:07 +0800</pubDate>
      
      <guid>https://wrfly.kfd.me/posts/gracefully-shutdown/</guid>
      <description>时间是宇宙唯一的资源 &amp;mdash; 我
 因为上周准备code review的时候遇到了这个问题，大家也给出了一些建议，和imcom哥也进行了一番讨论，了解了golang中context的一些用法，在这里记录备份一下，也希望对别人有所帮助。
首先简单的阐述一下问题是什么。golang编程，经常会go出去一些goroutine，抛出去不难，关键要看怎么收回来，因为程序不仅有启动，还要有退出，不管是正常退出还是非正常退出，总得有一个clean up的过程，不然就会导致程序不可控，引发非正常退出，数据丢失或者脏数据等一些乱七八糟的问题。
所以我们要在程序退出的时候对申请的资源进行释放，主动关闭已经建立的连接，完成正在进行的工作，然后退出程序。
github上有很多公开的让http服务graceful退出的lib，好像某些框架也提供了gracefulstop的方法。其本质就是停止服务，关闭端口，拒绝了新来的请求，然后把手头正在进行的请求处理完，或者设置一个超时时间强制结束正在进行的请求，然后server就stop了。这里我不谈论这个，因为有很多框架都自带了这个功能，而且不限于http服务。
但有个东西是要参考的，golang中的context。写过http服务的人都知道，每个请求的request中都带了一个context，一开始我是不知道这是做什么用的，但每个东西都有其用法，这个context的用法就是让server端和client联系起来的一个上下文，也可以理解为纽带。最基础的，比如client发出了一个请求，但是由于某种原因（网络断了，链接丢了，客户端主动关闭了，Ctrl+C了），这个连接断了，那么server端还要继续处理么，肯定不要了嘛，不然发给谁，给鬼啊，所以server就要根据这个context进行下一步处理，如果context已经done了，那么这个请求就可以直接return了。
说起来会很枯燥，看代码（跟上面说的server无关了哈，有点偏）：
package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) var wg sync.WaitGroup func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() n := 3 wg.Add(n) for i := 0; i &amp;lt; n; i++ { go testContext(ctx) } time.Sleep(2100 * time.Millisecond) cancel() wg.Wait() } func testContext(ctx context.Context) { defer wg.Done() defer fmt.Println(&amp;#34;stop&amp;#34;) tk := time.NewTicker(time.Second) defer tk.Stop() for { select { case &amp;lt;-ctx.</description>
    </item>
    
  </channel>
</rss>